# tp2-stockapp
Técnicas de programação II [3S 2024] 

# Aula 1: Introdução à Arquitetura Limpa
Definição de Arquitetura Limpa.
Princípios e benefícios.
Discussão sobre a importância da organização do código.
# Aula 2: Explorando Design Patterns
Definição de Design Patterns.
Apresentação dos principais padrões como Singleton, Factory, Strategy, etc.
Demonstração de como e quando aplicá-los na prática.
# Aula 3: Camadas no Modelo Anêmico
Conceito de camadas no modelo anêmico.
Exploração das camadas de apresentação, lógica de negócios e acesso a dados.
Discussão sobre as vantagens e desvantagens desse modelo.
# Aula 4: Camada de Infrastructure
O que é a camada de Infrastructure.
Funções e responsabilidades dessa camada.
Exemplos de implementação.
# Aula 5: Modelos e ORM Entities
Definição de modelos.
Explicação de ORM (Object-Relational Mapping) Entities.
Como os modelos se aplicam com ORM Entities.
# Aula 6: Migration em Bancos de Dados
Significado e importância de Migration.
Como usar Migration para atualizar esquemas de banco de dados.
Exemplos práticos de uso.
# Aula 7: Explorando a Camada de Application
O que é a camada de Application.
Sua relação com a camada de negócios.
Demonstração de implementações típicas.
# Aula 8: Implementações de Segurança
Diferentes abordagens de segurança em aplicações.
Autenticação e autorização.
Melhores práticas e padrões de segurança.
# Aula 9: Camada de Web API
Definição e função da camada de Web API.
Protocolos comuns usados (REST, GraphQL).
Como projetar uma Web API escalável e eficiente.
# Aula 10: Interfaces e Classes Repositórios
Significado e importância das Interfaces.
Conceito de Classes Repositórios.
Implementação e uso em uma aplicação.
# Aula 11: Testes Unitários com Fluent
Introdução aos testes unitários.
Uso do Fluent Assertions para escrever testes de forma mais legível.
Demonstração de casos de teste em uma aplicação.
# Aula 12: Testes Unitários com Xunit
Explicação do Xunit como framework de teste unitário.
Como escrever e executar testes usando Xunit.
Melhores práticas para testes unitários.
# Aula 13: Introdução ao Swagger para Documentação de Endpoints
O que é Swagger e sua importância na documentação de APIs.
Como integrar o Swagger em uma aplicação.
Demonstração de documentação de endpoints usando Swagger.
# Aula 14: Projetos Ativos: Desenvolvimento de uma Aplicação Web
Metodologia de projetos ativos.
Definição de um projeto prático de desenvolvimento de uma aplicação web.
Distribuição de tarefas e colaboração em equipe.
# Aula 15: STEAM: Introdução à Ciência de Dados
Introdução ao STEAM (Science, Technology, Engineering, Arts, Mathematics).
Aplicações da ciência de dados em projetos STEAM.
Exemplos práticos de análise de dados.
# Aula 16: Projetos Ativos: Implementação de Recursos de Segurança em uma Aplicação Web
Continuação do projeto prático iniciado na Aula 14.
Implementação de recursos de segurança como autenticação e autorização.
Teste e validação dos recursos implementados.
# Aula 17: STEAM: Arte e Tecnologia na Interface do Usuário
Exploração da interseção entre arte e tecnologia na interface do usuário.
Design centrado no usuário e usabilidade.
Atividade prática de design de interface.
# Aula 18: Projetos Ativos: Testes e Documentação
Finalização do projeto prático iniciado nas aulas anteriores.
Escrevendo testes unitários para garantir a qualidade do código.
Documentação completa dos endpoints usando Swagger.
# Aula 19: STEAM: Engenharia de Software e Criatividade
Como a criatividade influencia a engenharia de software.
Métodos para promover a criatividade no desenvolvimento de software.
Discussão sobre inovação e soluções criativas em tecnologia.
# Aula 20: Revisão Final e Apresentação de Projetos
Revisão dos conceitos aprendidos ao longo do curso.
Apresentação dos projetos desenvolvidos pelos alunos.
Feedback e discussão sobre os projetos apresentados.


